// Package SUSE Manager - SUSE Manager api call and support functions
package susemanager

import (
	"encoding/json"
	"errors"
	"reflect"
	"testing"

	"github.com/stretchr/testify/mock"
	"go.uber.org/zap"

	sumamodels "mlmtool/pkg/models/susemanager"
	logging "mlmtool/pkg/util/logger"
	"mlmtool/pkg/util/rest"
)

// MockISuseManagerAPI is an autogenerated mock type for the MockISuseManagerAPI type
type MockISuseManagerAPI struct {
	mock.Mock
}

// SuseManagerCall
//
// param: body
// param: method
// param: hostname
// param: path
// param: sessionKey
// return:
func (_m *MockISuseManagerAPI) SuseManagerCall(body []byte, method string, hostname string, path string, sessionKey string) (*rest.HTTPHelperStruct, error) {
	ret := _m.Called(body, method, hostname, path, sessionKey)

	var r0 *rest.HTTPHelperStruct
	if rf, ok := ret.Get(0).(func([]byte, string, string, string, string) *rest.HTTPHelperStruct); ok {
		r0 = rf(body, method, hostname, path, sessionKey)
	} else if ret.Get(0) != nil {
		r0 = ret.Get(0).(*rest.HTTPHelperStruct)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, string, string, string, string) error); ok {
		r1 = rf(body, method, hostname, path, sessionKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

func TestProxy_ListLatestInstallablePackages(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
	}
	logger := logging.NewTestingLogger(t.Name())
	type args struct {
		auth     AuthParams
		systemID int
	}

	header := make(map[string]string)
	header["Content-Type"] = "application/JSON"

	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}

	suseManagerMock := new(MockISuseManagerAPI)

	channelResp := []sumamodels.InstallablePackage{
		{
			Name:      "test package",
			Version:   "1.2.3.4",
			ArchLabel: "x64",
			ID:        1,
		},
	}

	success := sumamodels.RespAPISuccess{
		Success: true,
		Result:  channelResp,
	}

	channelByteArr, err := json.Marshal(success)
	if err != nil {
		panic(err)
	}

	helper := &rest.HTTPHelperStruct{
		Body:       channelByteArr,
		StatusCode: 200,
		Cookies:    nil,
	}

	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}

	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)

	suseManagerMockErr := new(MockISuseManagerAPI)

	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}

	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result":[{"id":123,"name":"test"}]}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result":[{"id":false,"name":"test"}]}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	suseManagerMockErr1 := new(MockISuseManagerAPI)
	negativeKeyStatusCode := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr1,
		logger:            logger,
	}
	suseManagerMockErr1.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth:     auth,
		systemID: 123,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "List Latest Installable Packages Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "List Latest Installable Packages Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "List Latest Installable Packages Status Code Negative",
			fields:  negativeKeyStatusCode,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "List Latest Installable Packages UnMarshal JSON Negative",
			fields:  negativeActivationKeyUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "List Latest Installable Packages UnMarshal JSON Resp Negative",
			fields:  negativeActivationKeyUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
			}
			_, err := p.ListLatestInstallablePackages(tt.args.auth, tt.args.systemID)
			if (err != nil) != tt.wantErr {
				t.Errorf("Proxy.ListLatestInstallablePackages() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}

func TestProxy_SystemListActiveSystems(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
	}
	logger := logging.NewTestingLogger(t.Name())
	type args struct {
		auth AuthParams
	}

	header := make(map[string]string)
	header["Content-Type"] = "application/JSON"

	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}

	suseManagerMock := new(MockISuseManagerAPI)

	channelResp := []sumamodels.ActiveSystem{
		{
			Name: "test package",
			ID:   1,
		},
	}

	success := sumamodels.RespAPISuccess{
		Success: true,
		Result:  channelResp,
	}

	channelByteArr, err := json.Marshal(success)
	if err != nil {
		panic(err)
	}

	helper := &rest.HTTPHelperStruct{
		Body:       channelByteArr,
		StatusCode: 200,
		Cookies:    nil,
	}

	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}

	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)

	suseManagerMockErr := new(MockISuseManagerAPI)

	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}

	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result":[{"id":123,"name":"test"}]}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result":[{"id":false,"name":"test"}]}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	suseManagerMockErr1 := new(MockISuseManagerAPI)
	negativeKeyStatusCode := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr1,
		logger:            logger,
	}
	suseManagerMockErr1.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth: auth,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "System List Active Systems Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "System List Active Systems Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "System List Active Systems Status Code Negative",
			fields:  negativeKeyStatusCode,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "System List Active Systems UnMarshal JSON Negative",
			fields:  negativeActivationKeyUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "System List Active Systems UnMarshal JSON Resp Negative",
			fields:  negativeActivationKeyUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
			}
			_, err := p.SystemListActiveSystems(tt.args.auth)
			if (err != nil) != tt.wantErr {
				t.Errorf("Proxy.SystemListActiveSystems() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}

func TestProxy_SystemListInstalledPackages(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
	}
	logger := logging.NewTestingLogger(t.Name())
	type args struct {
		auth     AuthParams
		systemID int
	}

	header := make(map[string]string)
	header["Content-Type"] = "application/JSON"

	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}

	suseManagerMock := new(MockISuseManagerAPI)

	channelResp := []sumamodels.InstalledPackage{
		{
			Name:      "test package",
			PackageID: 1,
			Version:   "1.2.3.4",
			Arch:      "x64",
		},
	}

	success := sumamodels.RespAPISuccess{
		Success: true,
		Result:  channelResp,
	}

	channelByteArr, err := json.Marshal(success)
	if err != nil {
		panic(err)
	}

	helper := &rest.HTTPHelperStruct{
		Body:       channelByteArr,
		StatusCode: 200,
		Cookies:    nil,
	}

	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}

	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)

	suseManagerMockErr := new(MockISuseManagerAPI)

	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}

	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result":[{"package_id":123,"name":"test"}]}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result":[{"package_id":false,"name":"test"}]}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	suseManagerMockErr1 := new(MockISuseManagerAPI)
	negativeKeyStatusCode := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr1,
		logger:            logger,
	}
	suseManagerMockErr1.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth: auth,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "System List Installed Packages Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "System List Installed Packages Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "System List Installed Packages Status Code Negative",
			fields:  negativeKeyStatusCode,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "System List Installed Packages UnMarshal JSON Negative",
			fields:  negativeActivationKeyUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "System List Installed Packages UnMarshal JSON Resp Negative",
			fields:  negativeActivationKeyUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
			}
			_, err := p.SystemListInstalledPackages(tt.args.auth, tt.args.systemID)
			if (err != nil) != tt.wantErr {
				t.Errorf("Proxy.SystemListInstalledPackages() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

		})
	}
}

func TestProxy_ListCompleteSystem(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
	}
	logger := logging.NewTestingLogger(t.Name())
	type args struct {
		auth     AuthParams
		actionID int
	}

	header := make(map[string]string)
	header["Content-Type"] = "application/JSON"

	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}

	suseManagerMock := new(MockISuseManagerAPI)

	var channelResp []interface{}
	channelResp = append(channelResp, 1)

	success := sumamodels.RespAPISuccess{
		Success: true,
		Result:  channelResp,
	}

	channelByteArr, err := json.Marshal(success)
	if err != nil {
		panic(err)
	}

	helper := &rest.HTTPHelperStruct{
		Body:       channelByteArr,
		StatusCode: 200,
		Cookies:    nil,
	}

	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}

	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)

	suseManagerMockErr := new(MockISuseManagerAPI)

	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}

	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result":"1"`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result":"0"`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth: auth,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "List Complete System Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "List Complete System Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "List Complete System UnMarshal JSON Negative",
			fields:  negativeActivationKeyUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "List Complete System UnMarshal JSON Resp Negative",
			fields:  negativeActivationKeyUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
			}
			_, err := p.ListCompleteSystem(tt.args.auth, tt.args.actionID)
			if (err != nil) != tt.wantErr {
				t.Errorf("Proxy.ListCompleteSystem() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}

func TestProxy_ListInprogressSystem(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
	}
	logger := logging.NewTestingLogger(t.Name())
	type args struct {
		auth     AuthParams
		actionID int
	}

	header := make(map[string]string)
	header["Content-Type"] = "application/JSON"

	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}

	suseManagerMock := new(MockISuseManagerAPI)

	var channelResp []interface{}
	channelResp = append(channelResp, 1)

	success := sumamodels.RespAPISuccess{
		Success: true,
		Result:  channelResp,
	}

	channelByteArr, err := json.Marshal(success)
	if err != nil {
		panic(err)
	}

	helper := &rest.HTTPHelperStruct{
		Body:       channelByteArr,
		StatusCode: 200,
		Cookies:    nil,
	}

	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}

	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)

	suseManagerMockErr := new(MockISuseManagerAPI)

	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}

	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result":"1"`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result":"0"`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth: auth,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "List Complete System Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "List Complete System Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "List Complete System UnMarshal JSON Negative",
			fields:  negativeActivationKeyUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "List Complete System UnMarshal JSON Resp Negative",
			fields:  negativeActivationKeyUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
			}
			_, err := p.ListInprogressSystem(tt.args.auth, tt.args.actionID)
			if (err != nil) != tt.wantErr {
				t.Errorf("Proxy.ListInprogressSystem() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}

func TestProxy_SystemGetScriptResult(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
	}
	logger := logging.NewTestingLogger(t.Name())
	type args struct {
		auth            AuthParams
		actionID        int
		resultCompleted int
	}

	header := make(map[string]string)
	header["Content-Type"] = "application/JSON"

	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}

	suseManagerMock := new(MockISuseManagerAPI)

	resp := []byte(`{"success":true,"result":[{"serverId":"123","startDate":"Aug 26, 2022, 04:06:32 PM","stopDate":"Aug 26, 2022, 04:06:32 PM","returnCode":"Aug 26, 2022, 04:06:32 PM","output":"test Output"}]}`)

	helper := &rest.HTTPHelperStruct{
		Body:       resp,
		StatusCode: 200,
		Cookies:    nil,
	}

	positiveScriptRunKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}

	negativeScriptRunKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}

	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)

	suseManagerMockErr := new(MockISuseManagerAPI)

	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}

	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result":[{"serverId":"123","output":"test"}]}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result":[{"serverId":false,"output":"test"}]}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeActivationKeyUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth:            auth,
		actionID:        123,
		resultCompleted: 1,
	}

	arg1 := args{
		auth:            auth,
		actionID:        123,
		resultCompleted: 0,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "System Get Script Result Positive",
			fields:  positiveScriptRunKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "System Get Script Result Request ID Negative",
			fields:  negativeScriptRunKey,
			args:    arg1,
			wantErr: true,
		},
		{
			name:    "System Get Script Result Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "System Get Script Result UnMarshal JSON Negative",
			fields:  negativeActivationKeyUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "System Get Script Result UnMarshal JSON Resp Negative",
			fields:  negativeActivationKeyUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
			}
			_, err := p.SystemGetScriptResult(tt.args.auth, tt.args.actionID, tt.args.resultCompleted)
			if (err != nil) != tt.wantErr {
				t.Errorf("Proxy.SystemGetScriptResult() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}

func TestProxy_SystemGetId(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
	}
	logger := logging.NewTestingLogger(t.Name())
	type args struct {
		auth       AuthParams
		systemName string
	}
	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth:       auth,
		systemName: "suse.dtblrrsys.com",
	}

	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}

	SuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result":[{"id": 123, "name":"suse.dtblrrsys.com", "outdated_pkg_count": 2}]}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	errHelper := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}
	//customtime, _ := time.Parse("Aug 26, 2022, 04:06:32 PM", "Aug 26, 2022, 04:06:32 PM")
	expectedresp := sumamodels.System{ID: 123, Name: "suse.dtblrrsys.com", OutdatedPkgCount: 2}

	var resparr []sumamodels.System
	resparr = append(resparr, expectedresp)

	suseManagerMock := new(MockISuseManagerAPI)
	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(SuccesssHelper, nil)

	suseManagerMock2 := new(MockISuseManagerAPI)
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errHelper, nil)

	header := make(map[string]string)
	header["Content-Type"] = "application/JSON"

	field := fields{
		cfg:               config,
		suse:              suseManagerMock,
		contentTypeHeader: header,
		logger:            logger,
	}
	field2 := fields{
		cfg:               config,
		suse:              suseManagerMock2,
		contentTypeHeader: header,
		logger:            logger,
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    []sumamodels.System
		wantErr bool
	}{
		{
			name:    "positivetestcase",
			fields:  field,
			args:    arg,
			want:    resparr,
			wantErr: false,
		},
		{
			name:    "negativetestcaseforstatuscode400",
			fields:  field2,
			args:    arg,
			want:    nil,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
			}
			got, err := p.SystemGetID(tt.args.auth, tt.args.systemName)
			if (err != nil) != tt.wantErr {
				t.Errorf("Proxy.SystemGetID() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Proxy.SystemGetID() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestProxy_SchedulePackageRefresh(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
		retrycount        int
	}
	type args struct {
		auth     AuthParams
		systemID int
	}
	logger := logging.NewTestingLogger(t.Name())
	header := make(map[string]string)
	header["Content-Type"] = "application/json"
	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}
	suseManagerMock := new(MockISuseManagerAPI)
	resp := []byte(`{"success":true,"result": 1}`)
	helper := &rest.HTTPHelperStruct{
		Body:       resp,
		StatusCode: 200,
		Cookies:    nil,
	}
	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}
	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)
	suseManagerMockErr := new(MockISuseManagerAPI)
	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}
	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMockErr1 := new(MockISuseManagerAPI)
	negativeKeyStatusCode := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr1,
		logger:            logger,
	}
	suseManagerMockErr1.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result": true}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	suseManagerMock4 := new(MockISuseManagerAPI)
	errMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock4,
		logger:            logger,
	}
	suseManagerMock4.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errMarshalJSONResp, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth:     auth,
		systemID: 1000100001,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Status Code Negative",
			fields:  negativeKeyStatusCode,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "UnMarshal Json Negative",
			fields:  negativeUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Marshal Json Resp Negative",
			fields:  negativeMarshalJSONErr,
			args:    arg,
			wantErr: true,
		}, {
			name:    "UnMarshal Json Resp Negative",
			fields:  negativeUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
				retrycount:        tt.fields.retrycount,
			}
			if err := p.SchedulePackageRefresh(tt.args.auth, tt.args.systemID); (err != nil) != tt.wantErr {
				t.Errorf("SchedulePackageRefresh() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestProxy_ScheduleScriptRun(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
		retrycount        int
	}
	type args struct {
		auth     AuthParams
		systemID int
		timeout  int
		script   string
	}
	logger := logging.NewTestingLogger(t.Name())
	header := make(map[string]string)
	header["Content-Type"] = "application/json"
	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}
	suseManagerMock := new(MockISuseManagerAPI)
	resp := []byte(`{"success":true,"result": 1}`)
	helper := &rest.HTTPHelperStruct{
		Body:       resp,
		StatusCode: 200,
		Cookies:    nil,
	}
	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}
	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)
	suseManagerMockErr := new(MockISuseManagerAPI)
	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}
	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMockErr1 := new(MockISuseManagerAPI)
	negativeKeyStatusCode := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr1,
		logger:            logger,
	}
	suseManagerMockErr1.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result": true}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	suseManagerMock4 := new(MockISuseManagerAPI)
	errMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock4,
		logger:            logger,
	}
	suseManagerMock4.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errMarshalJSONResp, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth:     auth,
		systemID: 1000100001,
		timeout:  120,
		script:   "/test/tst.sh",
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Status Code Negative",
			fields:  negativeKeyStatusCode,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "UnMarshal Json Negative",
			fields:  negativeUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Marshal Json Resp Negative",
			fields:  negativeMarshalJSONErr,
			args:    arg,
			wantErr: true,
		}, {
			name:    "UnMarshal Json Resp Negative",
			fields:  negativeUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
				retrycount:        tt.fields.retrycount,
			}
			if err := p.ScheduleScriptRun(tt.args.auth, tt.args.systemID, tt.args.timeout, tt.args.script); (err != nil) != tt.wantErr {
				t.Errorf("ScheduleScriptRun() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestProxy_SystemScheduleReboot(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
		retrycount        int
	}
	type args struct {
		auth     AuthParams
		systemID int
		timeout  int
	}
	logger := logging.NewTestingLogger(t.Name())
	header := make(map[string]string)
	header["Content-Type"] = "application/json"
	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}
	suseManagerMock := new(MockISuseManagerAPI)
	resp := []byte(`{"success":true,"result": 1}`)
	helper := &rest.HTTPHelperStruct{
		Body:       resp,
		StatusCode: 200,
		Cookies:    nil,
	}
	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}
	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)
	suseManagerMockErr := new(MockISuseManagerAPI)
	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}
	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMockErr1 := new(MockISuseManagerAPI)
	negativeKeyStatusCode := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr1,
		logger:            logger,
	}
	suseManagerMockErr1.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result": true}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	suseManagerMock4 := new(MockISuseManagerAPI)
	errMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock4,
		logger:            logger,
	}
	suseManagerMock4.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errMarshalJSONResp, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth:     auth,
		systemID: 1000100001,
		timeout:  120,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Status Code Negative",
			fields:  negativeKeyStatusCode,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "UnMarshal Json Negative",
			fields:  negativeUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Marshal Json Resp Negative",
			fields:  negativeMarshalJSONErr,
			args:    arg,
			wantErr: true,
		}, {
			name:    "UnMarshal Json Resp Negative",
			fields:  negativeUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
				retrycount:        tt.fields.retrycount,
			}
			if err := p.SystemScheduleReboot(tt.args.auth, tt.args.systemID, tt.args.timeout); (err != nil) != tt.wantErr {
				t.Errorf("SystemScheduleReboot() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestProxy_SystemScheduleApplyHighstate(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
		retrycount        int
	}
	type args struct {
		auth     AuthParams
		systemID int
		timeout  int
	}
	logger := logging.NewTestingLogger(t.Name())
	header := make(map[string]string)
	header["Content-Type"] = "application/json"
	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}
	suseManagerMock := new(MockISuseManagerAPI)
	resp := []byte(`{"success":true,"result": 1}`)
	helper := &rest.HTTPHelperStruct{
		Body:       resp,
		StatusCode: 200,
		Cookies:    nil,
	}
	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}
	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)
	suseManagerMockErr := new(MockISuseManagerAPI)
	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}
	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMockErr1 := new(MockISuseManagerAPI)
	negativeKeyStatusCode := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr1,
		logger:            logger,
	}
	suseManagerMockErr1.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result": true}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	suseManagerMock4 := new(MockISuseManagerAPI)
	errMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock4,
		logger:            logger,
	}
	suseManagerMock4.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errMarshalJSONResp, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth:     auth,
		systemID: 1000100001,
		timeout:  120,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Status Code Negative",
			fields:  negativeKeyStatusCode,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "UnMarshal Json Negative",
			fields:  negativeUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Marshal Json Resp Negative",
			fields:  negativeMarshalJSONErr,
			args:    arg,
			wantErr: true,
		}, {
			name:    "UnMarshal Json Resp Negative",
			fields:  negativeUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
				retrycount:        tt.fields.retrycount,
			}
			if err := p.SystemScheduleApplyHighstate(tt.args.auth, tt.args.systemID, tt.args.timeout); (err != nil) != tt.wantErr {
				t.Errorf("SystemScheduleApplyHighstate() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestProxy_SystemScheduleApplyStates(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
		retrycount        int
	}
	type args struct {
		auth       AuthParams
		systemID   int
		stateNames []string
		timeout    int
	}
	logger := logging.NewTestingLogger(t.Name())
	header := make(map[string]string)
	header["Content-Type"] = "application/json"
	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}
	suseManagerMock := new(MockISuseManagerAPI)
	resp := []byte(`{"success":true,"result": 1}`)
	helper := &rest.HTTPHelperStruct{
		Body:       resp,
		StatusCode: 200,
		Cookies:    nil,
	}
	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}
	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)
	suseManagerMockErr := new(MockISuseManagerAPI)
	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}
	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMockErr1 := new(MockISuseManagerAPI)
	negativeKeyStatusCode := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr1,
		logger:            logger,
	}
	suseManagerMockErr1.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result": true}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	suseManagerMock4 := new(MockISuseManagerAPI)
	errMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock4,
		logger:            logger,
	}
	suseManagerMock4.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errMarshalJSONResp, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}
	states := []string{"state1", "state2"}
	arg := args{
		auth:       auth,
		systemID:   1000100001,
		timeout:    120,
		stateNames: states,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Status Code Negative",
			fields:  negativeKeyStatusCode,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "UnMarshal Json Negative",
			fields:  negativeUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Marshal Json Resp Negative",
			fields:  negativeMarshalJSONErr,
			args:    arg,
			wantErr: true,
		}, {
			name:    "UnMarshal Json Resp Negative",
			fields:  negativeUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
				retrycount:        tt.fields.retrycount,
			}
			if err := p.SystemScheduleApplyStates(tt.args.auth, tt.args.systemID, tt.args.stateNames, tt.args.timeout); (err != nil) != tt.wantErr {
				t.Errorf("SystemScheduleApplyStates() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestProxy_SystemScheduleChangeChannels(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
		retrycount        int
	}
	type args struct {
		auth          AuthParams
		systemID      int
		basechannel   string
		childChannels []sumamodels.ChannelSoftwareListChildren
	}
	logger := logging.NewTestingLogger(t.Name())
	header := make(map[string]string)
	header["Content-Type"] = "application/json"
	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}
	suseManagerMock := new(MockISuseManagerAPI)
	resp := []byte(`{"success":true,"result": 1}`)
	helper := &rest.HTTPHelperStruct{
		Body:       resp,
		StatusCode: 200,
		Cookies:    nil,
	}
	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}
	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)
	suseManagerMockErr := new(MockISuseManagerAPI)
	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}
	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMockErr1 := new(MockISuseManagerAPI)
	negativeKeyStatusCode := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr1,
		logger:            logger,
	}
	suseManagerMockErr1.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock3 := new(MockISuseManagerAPI)
	errUnMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":true,"result": true}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONRespErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock3,
		logger:            logger,
	}
	suseManagerMock3.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errUnMarshalJSONResp, nil)

	suseManagerMock4 := new(MockISuseManagerAPI)
	errMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": 1}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock4,
		logger:            logger,
	}
	suseManagerMock4.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errMarshalJSONResp, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}
	childChannelsTest := []sumamodels.ChannelSoftwareListChildren{
		{
			ID:   1,
			Name: "cc1",
		},
		{
			ID:   2,
			Name: "cc2",
		},
	}
	arg := args{
		auth:          auth,
		systemID:      1000100001,
		basechannel:   "basechannel",
		childChannels: childChannelsTest,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Status Code Negative",
			fields:  negativeKeyStatusCode,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "UnMarshal Json Negative",
			fields:  negativeUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "Marshal Json Resp Negative",
			fields:  negativeMarshalJSONErr,
			args:    arg,
			wantErr: true,
		}, {
			name:    "UnMarshal Json Resp Negative",
			fields:  negativeUnMarshalJSONRespErr,
			args:    arg,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
				retrycount:        tt.fields.retrycount,
			}
			if err := p.SystemScheduleChangeChannels(tt.args.auth, tt.args.systemID, tt.args.basechannel, tt.args.childChannels); (err != nil) != tt.wantErr {
				t.Errorf("SystemScheduleChangeChannels() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestProxy_SystemGetSubscribedBaseChannel(t *testing.T) {
	type fields struct {
		cfg               *SumanConfig
		contentTypeHeader map[string]string
		suse              ISuseManagerAPI
		logger            *zap.Logger
		retrycount        int
	}
	type args struct {
		auth     AuthParams
		systemID int
	}
	logger := logging.NewTestingLogger(t.Name())

	header := make(map[string]string)
	header["Content-Type"] = "application/JSON"

	config := &SumanConfig{
		Host:     "test host",
		Password: "test",
		Insecure: true,
		Login:    "test",
	}

	suseManagerMock := new(MockISuseManagerAPI)

	channelResp := sumamodels.SubscribedBaseChannel{
		Name:  "channel_name",
		Label: "channel_label",
	}

	success := sumamodels.RespAPISuccess{
		Success: true,
		Result:  channelResp,
	}

	channelByteArr, err := json.Marshal(success)
	if err != nil {
		panic(err)
	}

	helper := &rest.HTTPHelperStruct{
		Body:       channelByteArr,
		StatusCode: 200,
		Cookies:    nil,
	}

	positiveKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock,
		logger:            logger,
	}

	suseManagerMock.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helper, nil)

	suseManagerMockErr := new(MockISuseManagerAPI)

	helperErr := &rest.HTTPHelperStruct{
		Body:       nil,
		StatusCode: 400,
		Cookies:    nil,
	}

	negativeKey := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMockErr,
		logger:            logger,
	}
	suseManagerMockErr.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(helperErr, errors.New("failed to call suse manager"))

	suseManagerMock2 := new(MockISuseManagerAPI)
	errSuccesssHelper := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result":{"name": "channel_name","label":"channel_label"}}`),
		StatusCode: 200,
		Cookies:    nil,
	}
	negativeUnMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock2,
		logger:            logger,
	}
	suseManagerMock2.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errSuccesssHelper, nil)

	suseManagerMock4 := new(MockISuseManagerAPI)
	errMarshalJSONResp := &rest.HTTPHelperStruct{
		Body:       []byte(`{"success":"abc","result": {"name": "channel_name","label":"channel_label"}}`),
		StatusCode: 200,
		Cookies:    nil,
	}

	negativeMarshalJSONErr := fields{
		cfg:               config,
		contentTypeHeader: header,
		suse:              suseManagerMock4,
		logger:            logger,
	}
	suseManagerMock4.On("SuseManagerCall", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(errMarshalJSONResp, nil)

	auth := AuthParams{
		SessionKey: "test key",
		Host:       "test Hostname",
	}

	arg := args{
		auth:     auth,
		systemID: 100010001,
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name:    "Positive",
			fields:  positiveKey,
			args:    arg,
			wantErr: false,
		},
		{
			name:    "Negative",
			fields:  negativeKey,
			args:    arg,
			wantErr: true,
		}, {
			name:    "Marshal Json Resp Negative",
			fields:  negativeMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
		{
			name:    "UnMarshal JSON Negative",
			fields:  negativeUnMarshalJSONErr,
			args:    arg,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &Proxy{
				cfg:               tt.fields.cfg,
				contentTypeHeader: tt.fields.contentTypeHeader,
				suse:              tt.fields.suse,
				logger:            tt.fields.logger,
				retrycount:        tt.fields.retrycount,
			}
			_, err := p.SystemGetSubscribedBaseChannel(tt.args.auth, tt.args.systemID)
			if (err != nil) != tt.wantErr {
				t.Errorf("SystemGetSubscribedBaseChannel() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}
